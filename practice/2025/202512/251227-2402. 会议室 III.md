# 官方链接
https://leetcode.cn/problems/meeting-rooms-iii/description/?envType=daily-question&envId=2025-12-27

## 题解
https://leetcode.cn/problems/meeting-rooms-iii/solutions/3866844/gomei-ri-yi-ti-by-code-review-pavi/

## Code
```go
type RoomHeap []int
func (h RoomHeap) Len() int           { return len(h) }
func (h RoomHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h RoomHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *RoomHeap) Push(x interface{}) { *h = append(*h, x.(int)) }
func (h *RoomHeap) Pop() interface{} {
    old := *h
    x := old[len(old) - 1]
    *h = old[: len(old) - 1]
    return x
}

type UsedRoom struct{ endTime, room int }
type UsedHeap []UsedRoom
func (h UsedHeap) Len() int           { return len(h) }
func (h UsedHeap) Less(i, j int) bool {
    if h[i].endTime == h[j].endTime {
        return h[i].room < h[j].room
    }
    return h[i].endTime < h[j].endTime
}
func (h UsedHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *UsedHeap) Push(x interface{}) { *h = append(*h, x.(UsedRoom)) }
func (h *UsedHeap) Pop() interface{} {
    old := *h
    x := old[len(old) - 1]
    *h = old[: len(old) - 1]
    return x
}

func mostBooked(n int, meetings [][]int) int {
    sort.Slice(meetings, func(i, j int) bool { return meetings[i][0] < meetings[j][0] })
    availRooms := &RoomHeap{}
    for i := 0; i < n; i++ {
        *availRooms = append(*availRooms, i)
    }
    heap.Init(availRooms)
    usedRooms := &UsedHeap{}
    heap.Init(usedRooms)
    usedCount := make([]int, n)
    curTime := 0
    for _, meeting := range meetings {
        if curTime < meeting[0] {
            curTime = meeting[0]
        }
        for usedRooms.Len() > 0 && (*usedRooms)[0].endTime <= curTime {
            heap.Push(availRooms, heap.Pop(usedRooms).(UsedRoom).room)
        }
        if availRooms.Len() == 0 {
            curTime = (*usedRooms)[0].endTime
            for usedRooms.Len() > 0 && (*usedRooms)[0].endTime <= curTime {
                heap.Push(availRooms, heap.Pop(usedRooms).(UsedRoom).room)
            }
        }
        room := heap.Pop(availRooms).(int)
        usedCount[room]++
        heap.Push(usedRooms, UsedRoom{curTime + meeting[1] - meeting[0], room})
    }
    ans := 0
    for i := 1; i < n; i++ {
        if usedCount[i] > usedCount[ans] {
            ans = i
        }
    }
    return ans
}
```