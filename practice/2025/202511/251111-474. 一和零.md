# 官方链接
https://leetcode.cn/problems/ones-and-zeroes/description/?envType=daily-question&envId=2025-11-11

## 题解
https://leetcode.cn/problems/ones-and-zeroes/solutions/3828477/gomei-ri-yi-ti-by-code-review-umgn/

## Code
```go
func findMaxForm(strs []string, m int, n int) int {
    // 定义：
    // 如果只使用前 i 个字符串，0 和 1 的限制分别为 j 和 k
    // 可以装的最大字符串数量是 dp[i][j][k]
    dp := make([][][]int, len(strs)+1)
    for i := range dp {
        dp[i] = make([][]int, m+1)
        for j := range dp[i] {
            dp[i][j] = make([]int, n+1)
        }
    }
    // base case:
    // dp[0][..][..] = 0
    // 如果没有任何字符串，那么可以装的最大字符串数量就是 0

    // 从 base case 开始状态转移
    for i := 1; i <= len(strs); i++ {
        // 注意有一位索引偏移
        curStr := strs[i-1]
        // 遍历每个字符串的 0 和 1 的个数
        zeroCount, oneCount := 0, 0
        for _, c := range curStr {
            if c == '0' {
                zeroCount++
            } else {
                oneCount++
            }
        }
        for j := 0; j <= m; j++ {
            for k := 0; k <= n; k++ {
                if j >= zeroCount && k >= oneCount {
                    // 有足够的空间把当前字符串装进背包
                    // 可以选择装或者不装，都计算一下，取最大值
                    dp[i][j][k] = max(
                        // 选择装当前字符串
                        dp[i-1][j-zeroCount][k-oneCount]+1,
                        // 不装当前字符串
                        dp[i-1][j][k],
                    )
                } else {
                    // 没有足够的空间把当前字符串装进背包
                    // 只能选择不装
                    dp[i][j][k] = dp[i-1][j][k]
                }
            }
        }
    }
    // 按照定义，返回结果
    return dp[len(strs)][m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```