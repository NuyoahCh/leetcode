# 官方链接
https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/description/?envType=daily-question&envId=2025-11-04

## 题解
https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/solutions/3822783/gomei-ri-yi-ti-by-code-review-hk5m/

## Code
```go
import "sort"

func findXSum(nums []int, k int, x int) []int {
	n := len(nums) - k + 1
	ans := make([]int, n)
	
	for i := 0; i < n; i++ {
		// 初始化计数数组 [值, 出现次数]
		// 由于 nums[i] ∈ [1,50]，用长度 51 的数组（索引 0 不使用）
		count := make([][2]int, 51)
		cnt := 0 // 不同元素个数
		
		// 统计当前窗口 [i, i+k-1] 的元素频次
		for j := i; j < i+k; j++ {
			val := nums[j]
			if count[val][1] == 0 {
				cnt++
				count[val][0] = val
			}
			count[val][1]++
		}
		
		// 实际需要取的元素种类数（不超过不同元素总数）
		temp := min(cnt, x)
		
		// 自定义排序：按出现次数降序，次数相同时按值降序
		sort.Slice(count, func(a, b int) bool {
			if count[a][1] != count[b][1] {
				return count[a][1] > count[b][1] // 次数多的在前
			}
			return count[a][0] > count[b][0] // 值大的在前
		})
		
		// 累加前 temp 个有效元素的总和
		sum := 0
		for m := 0; m < len(count) && temp > 0; m++ {
			if count[m][1] > 0 {
				temp--
				sum += count[m][0] * count[m][1]
			}
		}
		ans[i] = sum
	}
	
	return ans
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```