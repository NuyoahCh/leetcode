# 官方链接
https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/?envType=daily-question&envId=2026-01-10

## 题解
https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3876976/gomei-ri-yi-ti-by-code-review-defa/

## Code
```go
// 主函数
func minimumDeleteSum(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    // 备忘录值为 -1 代表未曾计算
    memo := make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }
    return dp(s1, 0, s2, 0, memo)
}

// 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，
// 最小的 ASCII 码之和为 dp(s1, i, s2, j)。
func dp(s1 string, i int, s2 string, j int, memo [][]int) int {
    res := 0
    // base case
    if i == len(s1) {
        // 如果 s1 到头了，那么 s2 剩下的都得删除
        for ; j < len(s2); j++ {
            res += int(s2[j])
        }
        return res
    }
    if j == len(s2) {
        // 如果 s2 到头了，那么 s1 剩下的都得删除
        for ; i < len(s1); i++ {
            res += int(s1[i])
        }
        return res
    }

    if memo[i][j] != -1 {
        return memo[i][j]
    }

    if s1[i] == s2[j] {
        // s1[i] 和 s2[j] 都是在 lcs 中的，不用删除
        memo[i][j] = dp(s1, i+1, s2, j+1, memo)
    } else {
        // s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个
        memo[i][j] = min(
            int(s1[i])+dp(s1, i+1, s2, j, memo),
            int(s2[j])+dp(s1, i, s2, j+1, memo),
        )
    }
    return memo[i][j]
}

// 备忘录
func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```