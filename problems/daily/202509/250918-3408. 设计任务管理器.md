# 官方链接
https://leetcode.cn/problems/design-task-manager/description/?envType=daily-question&envId=2025-09-18

## 题解
https://leetcode.cn/problems/design-task-manager/solutions/3785194/gomei-ri-yi-ti-by-code-review-2b47/

## Code
```go
type TaskManager struct {
    taskInfo map[int][2]int
    heap     *PriorityQueue
}

func Constructor(tasks [][]int) TaskManager {
    tm := TaskManager{
        taskInfo: make(map[int][2]int),
        heap:     &PriorityQueue{},
    }
    heap.Init(tm.heap)
    
    for _, task := range tasks {
        userId, taskId, priority := task[0], task[1], task[2]
        tm.taskInfo[taskId] = [2]int{priority, userId}
        heap.Push(tm.heap, Task{priority: priority, taskId: taskId})
    }
    return tm
}

func (this *TaskManager) Add(userId int, taskId int, priority int)  {
    this.taskInfo[taskId] = [2]int{priority, userId}
    heap.Push(this.heap, Task{priority: priority, taskId: taskId})
}

func (this *TaskManager) Edit(taskId int, newPriority int)  {
    if info, exists := this.taskInfo[taskId]; exists {
        info[0] = newPriority
        this.taskInfo[taskId] = info
        heap.Push(this.heap, Task{priority: newPriority, taskId: taskId})
    }
}

func (this *TaskManager) Rmv(taskId int)  {
    delete(this.taskInfo, taskId)
}

func (this *TaskManager) ExecTop() int {
    for this.heap.Len() > 0 {
        task := heap.Pop(this.heap).(Task)
        priority, taskId := task.priority, task.taskId
        if info, exists := this.taskInfo[taskId]; exists && info[0] == priority {
            userId := info[1]
            delete(this.taskInfo, taskId)
            return userId
        }
    }
    return -1
}

type Task struct {
    priority int
    taskId   int
}

type PriorityQueue []Task

func (pq PriorityQueue) Len() int { 
    return len(pq) 
}

func (pq PriorityQueue) Less(i, j int) bool {
    if pq[i].priority != pq[j].priority {
        return pq[i].priority > pq[j].priority
    }
    return pq[i].taskId > pq[j].taskId
}

func (pq PriorityQueue) Swap(i, j int) { 
    pq[i], pq[j] = pq[j], pq[i] 
}

func (pq *PriorityQueue) Push(x interface{}) { 
    *pq = append(*pq, x.(Task)) 
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n - 1]
    *pq = old[0 : n - 1]
    return item
}
```