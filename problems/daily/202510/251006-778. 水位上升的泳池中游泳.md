# 官方链接
https://leetcode.cn/problems/swim-in-rising-water/description/?envType=daily-question&envId=2025-10-06

## 题解
https://leetcode.cn/problems/swim-in-rising-water/solutions/3799012/gomei-ri-yi-ti-by-code-review-mnyy/

## Code
```go
type entry struct{ i, j, val int }
type hp []entry

func (h hp) Len() int            { return len(h) }
func (h hp) Less(i, j int) bool  { return h[i].val < h[j].val }
func (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }
func (h *hp) Push(v interface{}) { *h = append(*h, v.(entry)) }
func (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }

type pair struct{ x, y int }
var dirs = []pair{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}

func swimInWater(grid [][]int) (ans int) {
    n := len(grid)
    vis := make([][]bool, n)
    for i := range vis {
        vis[i] = make([]bool, n)
    }
    vis[0][0] = true
    h := &hp{{0, 0, grid[0][0]}}
    for {
        e := heap.Pop(h).(entry)
        ans = max(ans, e.val)
        if e.i == n-1 && e.j == n-1 {
            return
        }
        for _, d := range dirs {
            if x, y := e.i+d.x, e.j+d.y; 0 <= x && x < n && 0 <= y && y < n && !vis[x][y] {
                vis[x][y] = true
                heap.Push(h, entry{x, y, grid[x][y]})
            }
        }
    }
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```