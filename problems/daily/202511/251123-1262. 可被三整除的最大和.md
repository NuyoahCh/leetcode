# 官方链接
https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/?envType=daily-question&envId=2025-11-23

## 题解
https://leetcode.cn/problems/greatest-sum-divisible-by-three/solutions/3839506/gomei-ri-yi-ti-by-code-review-sv2e/

## Code
```go
func maxSumDivThree(nums []int) int {
    // 定义：nums[0..i] 中，和 3 相除余数为 j 的最大和是 dp[i][j]
    // 3 is dp[i][j]
    dp := make([][3]int, len(nums)+1)

    // base case
    // 如果不用数字，最大元素和就是 0
    // 余数必然是 0，不可能出现余数为 1 或 2 的情况
    dp[0][0] = 0
    dp[0][1] = math.MinInt32
    dp[0][2] = math.MinInt32

    // 状态转移方程
    // 我们可以根据第 i 个数字余数和前 i-1 个数字的余数情况
    // 来推导出前 i 个数字的余数情况
    for i := 1; i <= len(nums); i++ {
        curNum := nums[i-1]
        if curNum%3 == 0 {
            // dp[i][0] = max(dp[i-1][0] + curNum, dp[i-1][0])
            // dp[i][1] = max(dp[i-1][1] + curNum, dp[i-1][1])
            // dp[i][2] = max(dp[i-1][2] + curNum, dp[i-1][2])
            // 可化简：
            dp[i][0] = dp[i-1][0] + curNum
            dp[i][1] = dp[i-1][1] + curNum
            dp[i][2] = dp[i-1][2] + curNum
        } else if curNum%3 == 1 {
            dp[i][0] = max(dp[i-1][2]+curNum, dp[i-1][0])
            dp[i][1] = max(dp[i-1][0]+curNum, dp[i-1][1])
            dp[i][2] = max(dp[i-1][1]+curNum, dp[i-1][2])
        } else {
            dp[i][0] = max(dp[i-1][1]+curNum, dp[i-1][0])
            dp[i][1] = max(dp[i-1][2]+curNum, dp[i-1][1])
            dp[i][2] = max(dp[i-1][0]+curNum, dp[i-1][2])
        }
    }

    return dp[len(nums)][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```