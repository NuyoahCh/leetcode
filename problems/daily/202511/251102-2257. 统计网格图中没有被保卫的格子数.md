# 官方链接
https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/description/?envType=daily-question&envId=2025-11-02

## 题解
https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/solutions/3821266/gomei-ri-yi-ti-by-code-review-n3rr/

## Code
```go
func countUnguarded(m int, n int, guards [][]int, walls [][]int) int {
	grid := make([][]int, m)   // 网格状态数组
	for i := range grid {
		grid[i] = make([]int, n)
	}
	q := [][3]int{}   // 广度优先搜索队列
	// 每个方向的单位向量
	dx := []int{1, 0, -1, 0}
	dy := []int{0, 1, 0, -1}
	for _, guard := range guards {
		grid[guard[0]][guard[1]] = -1
		for k := 0; k < 4; k++ {
			// 将四个方向视线对应的状态均添加进搜索队列中
			q = append(q, [3]int{guard[0], guard[1], k})
		}
	}
	for _, wall := range walls {
		grid[wall[0]][wall[1]] = -2
	}
	for len(q) > 0 {
		curr := q[0]
		q = q[1:]
		x, y, k := curr[0], curr[1], curr[2]
		nx := x + dx[k]
		ny := y + dy[k]
		if nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] >= 0 {
			// 沿着视线方向的下一个坐标合法，且不为警卫或墙
			if (grid[nx][ny] & (1 << k)) == 0 {
				// 对应状态未遍历过
				grid[nx][ny] |= (1 << k)
				q = append(q, [3]int{nx, ny, k})
			}
		}
	}
	res := 0   // 未被保护格子数目
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 0 {
				res++
			}
		}
	}
	return res
}
```